---
name: postgres
description: Configure DigitalOcean Managed Postgres databases. Recommends Path A (doctl + bindable variables) for most apps, with Path B (schema isolation + GitHub Secrets) for multi-tenant architectures. Includes hands-free secure setup that stores credentials directly in GitHub Secrets.
version: 2.1.0
author: Bikram Gupta
triggers:
  - "database"
  - "postgres"
  - "postgresql"
  - "schema"
  - "database user"
  - "permissions"
  - "connection string"
  - "connection pool"
  - "multi-tenant database"
  - "db setup"
  - "bindable variables"
dependencies:
  - designer (for app spec database attachment)
  - deployment (for GitHub Actions integration)
  - troubleshooting (for connectivity issues)
  - dev-containers (for local Postgres parity)
tools:
  required:
    - doctl (authenticated)
    - psql (PostgreSQL client)
  optional:
    - gh (GitHub CLI - for hands-free secure setup)
artifacts:
  path_a:
    - db-permissions-path-a.sql
  path_b:
    - db-setup.sql
    - db-users.sql
    - db-permissions.sql
    - db-connections.env
    - DB-SETUP.md
---

# Postgres Skill

Configure DigitalOcean Managed Postgres databases with proper security isolation, multi-tenant patterns, and production-ready defaults.

---

## Critical Concept: Two Paths for Database Setup

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CHOOSE YOUR PATH                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  PATH A: BINDABLE VARIABLES (RECOMMENDED FOR MOST APPS)                      │
│  ─────────────────────────────────────────────────────────────────────────   │
│  • Create users/databases via doctl or Console                               │
│  • DO stores passwords internally — you never see them                       │
│  • App Platform auto-populates ${db.DATABASE_URL} in your app                │
│  • Still need to grant permissions via doadmin                               │
│                                                                              │
│  Best for: Single app per database, standard CRUD applications               │
│                                                                              │
│  PATH B: SCHEMA ISOLATION (FOR MULTI-TENANT / ADVANCED)                      │
│  ─────────────────────────────────────────────────────────────────────────   │
│  • Create schemas and users via raw SQL                                      │
│  • You manage passwords (store in GitHub Secrets)                            │
│  • Use manual env vars in app spec                                           │
│  • Full control over schema-level isolation                                  │
│                                                                              │
│  Best for: Multi-tenant SaaS, multiple apps sharing one cluster              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Decision Tree

```
Do you need multiple isolated schemas in one database?
    │
    ├── YES → PATH B (Schema Isolation + GitHub Secrets)
    │
    └── NO → Are multiple apps sharing this cluster?
              │
              ├── YES, but each gets own database → PATH A (create DB per app)
              │
              └── NO, single app → PATH A (Bindable Variables) ✅ RECOMMENDED
```

---

## PATH A: Bindable Variables (Recommended)

### How It Works

When you create users via DigitalOcean's interface (Console, API, or `doctl`), **DO stores the credentials internally**. App Platform can then automatically retrieve these credentials and populate bindable environment variables.

```
┌─────────────────────────────────────────────────────────────────┐
│                    DigitalOcean Internal Systems                │
│  ┌─────────────────┐         ┌─────────────────────────────┐   │
│  │ Managed Database │         │   Credential Store          │   │
│  │    Cluster       │         │   (users created via DO)    │   │
│  │                  │         │                             │   │
│  │  - doadmin       │◄───────►│  doadmin: <auto-generated>  │   │
│  │  - myappuser     │         │  myappuser: <auto-generated>│   │
│  └─────────────────┘         └──────────────▲──────────────┘   │
│                                              │                  │
│  ┌─────────────────┐                         │                  │
│  │   App Platform   │─────────────────────────┘                  │
│  │                  │  Queries credentials by                   │
│  │  app spec:       │  cluster_name + db_user                   │
│  │  - cluster_name  │                                           │
│  │  - db_user       │──────► Populates ${db.DATABASE_URL}       │
│  └─────────────────┘                                            │
└─────────────────────────────────────────────────────────────────┘
```

### Step-by-Step Setup

**Step 1: Create cluster, database, and user via doctl**

```bash
# Create cluster (or use existing)
doctl databases create my-app-db \
  --engine pg \
  --region nyc3 \
  --size db-s-1vcpu-2gb \
  --version 16

# Get cluster ID
CLUSTER_ID=$(doctl databases list --format ID,Name --no-header | grep my-app-db | awk '{print $1}')

# Create database within cluster
doctl databases db create $CLUSTER_ID myappdb

# Create user (DO generates and stores the password - you never see it)
doctl databases user create $CLUSTER_ID myappuser

# Verify
doctl databases user list $CLUSTER_ID
doctl databases db list $CLUSTER_ID
```

**Step 2: Grant permissions (REQUIRED - this is the gap!)**

Even though DO manages the password, the user has NO permissions by default.

```bash
# Get admin connection string
ADMIN_URL=$(doctl databases connection $CLUSTER_ID --format Uri --no-header)

# Connect as doadmin and grant permissions
psql "$ADMIN_URL" << 'EOF'
-- Grant connection to the database
GRANT CONNECT ON DATABASE myappdb TO myappuser;

-- Connect to the database
\c myappdb

-- Grant schema usage and table permissions
GRANT USAGE ON SCHEMA public TO myappuser;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO myappuser;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO myappuser;

-- For future tables created by migrations
ALTER DEFAULT PRIVILEGES IN SCHEMA public 
  GRANT ALL ON TABLES TO myappuser;
ALTER DEFAULT PRIVILEGES IN SCHEMA public 
  GRANT ALL ON SEQUENCES TO myappuser;
EOF

echo "✅ Permissions granted to myappuser on myappdb"
```

**Generate `db-permissions-path-a.sql`** for this step:
```sql
-- ============================================
-- Permission Setup for Path A (Bindable Variables)
-- Run as doadmin after creating user via doctl
-- ============================================

-- Grant connection to database
GRANT CONNECT ON DATABASE {db_name} TO {username};

-- Connect to the target database
\c {db_name}

-- Grant schema and table permissions
GRANT USAGE ON SCHEMA public TO {username};
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO {username};
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO {username};

-- For future tables (migrations, ORMs)
ALTER DEFAULT PRIVILEGES IN SCHEMA public 
  GRANT ALL ON TABLES TO {username};
ALTER DEFAULT PRIVILEGES IN SCHEMA public 
  GRANT ALL ON SEQUENCES TO {username};
```

**Step 3: Reference in app spec**

```yaml
# .do/app.yaml
databases:
  - name: db                    # Component name (used in bindable vars)
    engine: PG
    production: true            # REQUIRED: signals this is a managed database
    cluster_name: my-app-db     # Must match existing cluster name exactly
    db_name: myappdb            # Database within cluster
    db_user: myappuser          # User created via doctl

services:
  - name: api
    # ... other config ...
    envs:
      - key: DATABASE_URL
        scope: RUN_TIME
        value: ${db.DATABASE_URL}
```

**Step 4: Deploy and verify**

```bash
# Deploy
doctl apps create --spec .do/app.yaml

# Verify bindable variables are populated (use troubleshooting skill's Alpine debug pattern)
# In running container:
echo $DATABASE_URL
# Should output: postgresql://myappuser:AVNS_xxx@host:25060/myappdb?sslmode=require
```

### Available Bindable Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `${db.DATABASE_URL}` | Full connection string | `postgresql://myappuser:AVNS_xxx@host:25060/myappdb?sslmode=require` |
| `${db.HOSTNAME}` | Database host | `my-app-db-do-user-123.db.ondigitalocean.com` |
| `${db.PORT}` | Database port | `25060` |
| `${db.USERNAME}` | Database user | `myappuser` |
| `${db.PASSWORD}` | Database password | (auto-populated by DO) |
| `${db.DATABASE}` | Database name | `myappdb` |
| `${db.CA_CERT}` | CA certificate for TLS | (certificate content) |

Where `db` is the component name from your app spec.

### Connection Pools with Bindable Variables

```yaml
envs:
  - key: DATABASE_POOL_URL
    scope: RUN_TIME
    value: ${db.my-pool-name.DATABASE_URL}
```

Where `my-pool-name` is a connection pool created via:
```bash
doctl databases pool create $CLUSTER_ID my-pool-name \
  --db myappdb \
  --mode transaction \
  --size 25 \
  --user myappuser
```

### Critical Requirements for Path A

| Requirement | Why |
|-------------|-----|
| User created via DO interface | DO must have the password stored internally |
| `production: true` in app spec | Tells App Platform this is a managed (not dev) database |
| `cluster_name` matches exactly | App Platform looks up the cluster by name |
| Cluster must exist before deploy | Unlike dev DBs, managed DBs aren't auto-created |
| **Permissions granted via doadmin** | Users have no access by default! |

### What Does NOT Work with Bindable Variables

❌ **Users created via raw SQL**
```sql
-- This user's password is NOT stored by DO
CREATE USER myuser WITH PASSWORD 'mypassword';
```
App Platform cannot retrieve passwords for users created this way. Use Path B instead.

❌ **External databases (not DO managed)**
Bindable variables only work with DigitalOcean Managed Databases.

---

## PATH B: Schema Isolation (Multi-Tenant / Advanced)

Use this path when you need:
- Multiple apps sharing one database with isolated schemas
- Multi-tenant architecture with per-tenant schemas
- Fine-grained control over user credentials
- Schema-level permission boundaries

### Security Model for Path B

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      PATH B: CREDENTIAL MANAGEMENT                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  OPTION 1: HANDS-FREE SECURE SETUP (RECOMMENDED)                         │
│  ─────────────────────────────────────────────────────────────────────   │
│  • Agent generates password, creates user, stores in GitHub Secrets      │
│  • Password NEVER displayed — flows directly to secrets                  │
│  • User can audit the script before execution                            │
│  • Requires: gh CLI authenticated with repo access                       │
│                                                                          │
│  OPTION 2: MANUAL SETUP                                                  │
│  ─────────────────────────────────────────────────────────────────────   │
│  • Generate SQL scripts with password placeholders                       │
│  • User generates password, edits scripts, executes                      │
│  • User manually adds to GitHub Secrets                                  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Hands-Free Secure Setup (Recommended for Path B)

When `gh` CLI is available and authenticated, the agent can set up everything securely:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     ZERO-KNOWLEDGE WORKFLOW                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  PASSWORD=$(openssl rand -base64 32)                                     │
│       │                                                                  │
│       ├──► psql: CREATE USER myapp_user WITH PASSWORD '$PASSWORD'        │
│       │                                                                  │
│       └──► gh secret set DATABASE_URL --repo owner/repo --body "..."     │
│                                                                          │
│  Password NEVER printed. Flows directly: generate → SQL → GitHub Secret  │
│                                                                          │
│  Agent sees it momentarily in memory, but:                               │
│  • Never outputs it to conversation                                      │
│  • Never logs it                                                         │
│  • User can audit the script before execution                            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**User Consent Pattern**:

Before executing, always ask:

```
Agent: "I can set up the database user and store credentials directly in 
        GitHub Secrets. The password will be generated securely and will 
        never be displayed — it goes straight from generation to your 
        secrets.
        
        Repository: owner/repo
        Environment: production (optional)
        Secret name: DATABASE_URL
        
        Want me to proceed? You can review the script first if you'd like."

User: "Yes, do it" / "Show me the script first"
```

**Prerequisites check**:
```bash
# Verify gh is authenticated and has repo access
gh auth status
gh secret list --repo owner/repo  # Test access
```

**Use the hands-free script**:
```bash
# Single command — password never visible
./scripts/secure_setup.sh \
  --admin-url "$ADMIN_URL" \
  --app-name myapp \
  --schema myapp \
  --repo owner/repo \
  --env production
```

See `scripts/secure_setup.sh` for the full implementation.

### Quick Start for Path B (Manual)

**User says**: "I need separate schemas for multiple apps sharing one database"

**Generate these artifacts**:

1. `db-setup.sql` — Schema creation
2. `db-users.sql` — User creation (password placeholders)
3. `db-permissions.sql` — Grant statements with schema isolation
4. `db-connections.env` — Connection string templates
5. `DB-SETUP.md` — Execution instructions

---

## Workflows

### Workflow 1: Single App Database (Path A - Recommended)

**Trigger**: "Set up a database for my app" / "I need Postgres for [app-name]"

**Recommend Path A** unless user specifically needs schema isolation.

**Step 1: Create resources via doctl**
```bash
# Get cluster ID (or create new cluster)
CLUSTER_ID=$(doctl databases list --format ID,Name --no-header | grep my-cluster | awk '{print $1}')

# Create database
doctl databases db create $CLUSTER_ID {app_name}db

# Create user (DO manages password automatically)
doctl databases user create $CLUSTER_ID {app_name}user
```

**Step 2: Generate `db-permissions-path-a.sql`**
```sql
-- ============================================
-- Permission Setup for: {app_name}
-- Path A: Bindable Variables
-- Run as doadmin after creating user via doctl
-- ============================================

-- Grant connection to database
GRANT CONNECT ON DATABASE {app_name}db TO {app_name}user;

-- Connect to the target database
\c {app_name}db

-- Grant schema and table permissions  
GRANT USAGE ON SCHEMA public TO {app_name}user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO {app_name}user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO {app_name}user;

-- For future tables (migrations, ORMs)
ALTER DEFAULT PRIVILEGES IN SCHEMA public 
  GRANT ALL ON TABLES TO {app_name}user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public 
  GRANT ALL ON SEQUENCES TO {app_name}user;
```

**Step 3: Execute permissions**
```bash
ADMIN_URL=$(doctl databases connection $CLUSTER_ID --format Uri --no-header)
psql "$ADMIN_URL" -f db-permissions-path-a.sql
```

**Step 4: Generate app spec snippet**
```yaml
# Add to .do/app.yaml
databases:
  - name: db
    engine: PG
    production: true
    cluster_name: my-cluster        # Your cluster name
    db_name: {app_name}db
    db_user: {app_name}user

services:
  - name: api
    envs:
      - key: DATABASE_URL
        scope: RUN_TIME
        value: ${db.DATABASE_URL}
```

**Step 5: Deploy**
→ Hand off to **deployment skill** or:
```bash
doctl apps create --spec .do/app.yaml
```

---

### Workflow 2: Single App with Schema (Path B)

**Trigger**: "I want to use a named schema" / "Set up a database with custom schema"

Use this when you want schema organization but still single-tenant.

**Generate `db-setup.sql`**:
```sql
-- ============================================
-- Database Setup for: {app_name}
-- Path B: Schema Isolation
-- ============================================

\c defaultdb

-- Create application schema (recommended over using public)
CREATE SCHEMA IF NOT EXISTS {app_name};
```

**Generate `db-users.sql`**:
```sql
-- ============================================
-- User Setup for: {app_name}
-- ============================================
-- Generate password with: openssl rand -base64 32

CREATE USER {app_name}_user WITH PASSWORD 'CHANGE_ME_SECURE_PASSWORD';
```

**Generate `db-permissions.sql`**:
```sql
-- ============================================
-- Permissions for: {app_name}
-- Path B: Schema Isolation
-- ============================================

-- Grant schema access
GRANT USAGE ON SCHEMA {app_name} TO {app_name}_user;

-- Grant table permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA {app_name} TO {app_name}_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA {app_name} TO {app_name}_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA {app_name} TO {app_name}_user;

-- For future objects
ALTER DEFAULT PRIVILEGES IN SCHEMA {app_name} 
  GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO {app_name}_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA {app_name} 
  GRANT USAGE, SELECT ON SEQUENCES TO {app_name}_user;

-- Set default search_path
ALTER USER {app_name}_user SET search_path TO {app_name};

-- SECURITY: Revoke public schema access
REVOKE ALL ON SCHEMA public FROM {app_name}_user;
```

**Generate `db-connections.env`**:
```bash
# Path B: Store in GitHub Secrets
# Generate password: openssl rand -base64 32

DATABASE_URL=postgresql://{app_name}_user:PASSWORD@HOST:25060/defaultdb?sslmode=require
DB_SCHEMA={app_name}
```

**Credential storage**: → Hand off to **deployment skill** for GitHub Secrets setup.

---

### Workflow 3: Multi-App Shared Cluster

**Trigger**: "I have multiple apps sharing one Postgres cluster" / "Set up 3 apps on one database"

**First, ask**: Do the apps need to be isolated from each other?

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    MULTI-APP ARCHITECTURE OPTIONS                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  PATH A: Separate Databases (RECOMMENDED - Bindable Variables)           │
│  ─────────────────────────────────────────────────────────────────────   │
│  Each app gets its own database within the cluster                       │
│                                                                          │
│  Cluster: my-cluster                                                     │
│  ├── app1db  ←── app1user (via doctl, uses ${app1.DATABASE_URL})        │
│  ├── app2db  ←── app2user (via doctl, uses ${app2.DATABASE_URL})        │
│  └── app3db  ←── app3user (via doctl, uses ${app3.DATABASE_URL})        │
│                                                                          │
│  ✓ Uses bindable variables (no manual credential management!)            │
│  ✓ Complete isolation (no cross-DB queries possible)                     │
│  ✓ Each app references its own ${dbname.DATABASE_URL}                    │
│                                                                          │
│  PATH B: Schema Isolation (GitHub Secrets Required)                      │
│  ─────────────────────────────────────────────────────────────────────   │
│  Single database with separate schemas                                   │
│                                                                          │
│  └── defaultdb                                                           │
│      ├── app1 schema  ←── app1_user (SQL, manual credentials)           │
│      ├── app2 schema  ←── app2_user (SQL, manual credentials)           │
│      └── app3 schema  ←── app3_user (SQL, manual credentials)           │
│                                                                          │
│  ✓ Easy cross-app queries if needed (with grants)                        │
│  ✓ Single database to backup/manage                                      │
│  ✗ Manual credential management via GitHub Secrets                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### Path A: Separate Databases (Recommended)

```bash
# For each app:
doctl databases db create $CLUSTER_ID app1db
doctl databases user create $CLUSTER_ID app1user

doctl databases db create $CLUSTER_ID app2db
doctl databases user create $CLUSTER_ID app2user

doctl databases db create $CLUSTER_ID app3db
doctl databases user create $CLUSTER_ID app3user
```

**Generate `db-permissions-multi-path-a.sql`** (run as doadmin):
```sql
-- Permissions for multi-app Path A setup
-- Run once for each app

-- App 1
GRANT CONNECT ON DATABASE app1db TO app1user;
\c app1db
GRANT USAGE ON SCHEMA public TO app1user;
GRANT ALL ON ALL TABLES IN SCHEMA public TO app1user;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO app1user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO app1user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO app1user;

-- App 2
\c defaultdb
GRANT CONNECT ON DATABASE app2db TO app2user;
\c app2db
GRANT USAGE ON SCHEMA public TO app2user;
GRANT ALL ON ALL TABLES IN SCHEMA public TO app2user;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO app2user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO app2user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO app2user;

-- App 3
\c defaultdb
GRANT CONNECT ON DATABASE app3db TO app3user;
\c app3db
GRANT USAGE ON SCHEMA public TO app3user;
GRANT ALL ON ALL TABLES IN SCHEMA public TO app3user;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO app3user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO app3user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO app3user;
```

**App spec with multiple databases**:
```yaml
databases:
  - name: app1
    engine: PG
    production: true
    cluster_name: my-cluster
    db_name: app1db
    db_user: app1user
  - name: app2
    engine: PG
    production: true
    cluster_name: my-cluster
    db_name: app2db
    db_user: app2user
  - name: app3
    engine: PG
    production: true
    cluster_name: my-cluster
    db_name: app3db
    db_user: app3user

services:
  - name: app1-api
    envs:
      - key: DATABASE_URL
        value: ${app1.DATABASE_URL}
  - name: app2-api
    envs:
      - key: DATABASE_URL
        value: ${app2.DATABASE_URL}
  - name: app3-api
    envs:
      - key: DATABASE_URL
        value: ${app3.DATABASE_URL}
```

#### Path B: Schema Isolation

**Generate `db-setup.sql`**:
```sql
-- Multi-App Schema Setup (Path B)
\c defaultdb

CREATE SCHEMA IF NOT EXISTS {app1};
CREATE SCHEMA IF NOT EXISTS {app2};
CREATE SCHEMA IF NOT EXISTS {app3};
```

**Generate `db-users.sql`**:
```sql
-- Generate passwords: openssl rand -base64 32
CREATE USER {app1}_user WITH PASSWORD 'CHANGE_ME_APP1_PASSWORD';
CREATE USER {app2}_user WITH PASSWORD 'CHANGE_ME_APP2_PASSWORD';
CREATE USER {app3}_user WITH PASSWORD 'CHANGE_ME_APP3_PASSWORD';
```

**Generate `db-permissions.sql`**:
```sql
-- ============================================
-- Multi-App Permissions (Schema Isolation)
-- ============================================

-- App 1 permissions
GRANT USAGE ON SCHEMA {app1} TO {app1}_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA {app1} TO {app1}_user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA {app1} TO {app1}_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA {app1} GRANT ALL ON TABLES TO {app1}_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA {app1} GRANT ALL ON SEQUENCES TO {app1}_user;
ALTER USER {app1}_user SET search_path TO {app1};
REVOKE ALL ON SCHEMA public FROM {app1}_user;

-- App 2 permissions
GRANT USAGE ON SCHEMA {app2} TO {app2}_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA {app2} TO {app2}_user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA {app2} TO {app2}_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA {app2} GRANT ALL ON TABLES TO {app2}_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA {app2} GRANT ALL ON SEQUENCES TO {app2}_user;
ALTER USER {app2}_user SET search_path TO {app2};
REVOKE ALL ON SCHEMA public FROM {app2}_user;

-- App 3 permissions
GRANT USAGE ON SCHEMA {app3} TO {app3}_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA {app3} TO {app3}_user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA {app3} TO {app3}_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA {app3} GRANT ALL ON TABLES TO {app3}_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA {app3} GRANT ALL ON SEQUENCES TO {app3}_user;
ALTER USER {app3}_user SET search_path TO {app3};
REVOKE ALL ON SCHEMA public FROM {app3}_user;

-- Verify isolation (each user should only see their schema)
-- Run as each user to verify:
-- SELECT schema_name FROM information_schema.schemata;
```

---

### Workflow 4: Read-Only User (Analytics/Reporting)

**Trigger**: "I need a read-only user" / "Set up analytics access"

#### Path A: Create via doctl (for bindable variables)

```bash
# Create read-only user via doctl
doctl databases user create $CLUSTER_ID {app_name}reader
```

**Generate `db-permissions-readonly-path-a.sql`** (run as doadmin):
```sql
-- Read-Only Permissions for Path A
GRANT CONNECT ON DATABASE {app_name}db TO {app_name}reader;
\c {app_name}db

-- Grant SELECT only (read-only)
GRANT USAGE ON SCHEMA public TO {app_name}reader;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO {app_name}reader;

-- For future tables
ALTER DEFAULT PRIVILEGES IN SCHEMA public 
  GRANT SELECT ON TABLES TO {app_name}reader;
```

Then reference in app spec:
```yaml
databases:
  - name: readonly
    engine: PG
    production: true
    cluster_name: my-cluster
    db_name: {app_name}db
    db_user: {app_name}reader

services:
  - name: analytics
    envs:
      - key: DATABASE_URL
        value: ${readonly.DATABASE_URL}
```

#### Path B: Create via SQL (for schema isolation)

**Generate `db-users.sql` addition**:
```sql
-- Read-Only User for Analytics
-- Generate password: openssl rand -base64 32
CREATE USER {app_name}_reader WITH PASSWORD 'CHANGE_ME_READONLY_PASSWORD';
```

**Generate `db-permissions.sql` addition**:
```sql
-- Read-Only Permissions (Schema Isolation)
GRANT USAGE ON SCHEMA {app_name} TO {app_name}_reader;
GRANT SELECT ON ALL TABLES IN SCHEMA {app_name} TO {app_name}_reader;

ALTER DEFAULT PRIVILEGES IN SCHEMA {app_name} 
  GRANT SELECT ON TABLES TO {app_name}_reader;

ALTER USER {app_name}_reader SET search_path TO {app_name};
REVOKE ALL ON SCHEMA public FROM {app_name}_reader;
```

#### Using Read Replica

For heavy analytics queries, use a read replica:
```bash
# Create replica
doctl databases replica create $CLUSTER_ID analytics-replica \
  --region nyc3 \
  --size db-s-1vcpu-2gb

# Get replica connection
doctl databases replica connection $CLUSTER_ID analytics-replica
```

---

### Workflow 5: Connection Pooling

**Trigger**: "Too many connections" / "Connection pool" / "PgBouncer"

**Diagnose the issue**:
```sql
-- Check current connections
SELECT count(*) FROM pg_stat_activity;

-- Check max connections
SHOW max_connections;

-- See who's connected
SELECT usename, application_name, client_addr, state, query_start
FROM pg_stat_activity
WHERE datname = 'defaultdb'
ORDER BY query_start DESC;
```

**Solution: DO Managed Connection Pool** (works with both paths)

```bash
# Create connection pool via doctl
doctl databases pool create $CLUSTER_ID {app_name}_pool \
  --db {app_name}db \
  --mode transaction \
  --size 25 \
  --user {app_name}user

# Get pool connection string
doctl databases pool get $CLUSTER_ID {app_name}_pool
```

**Use pool with bindable variables** (Path A):
```yaml
databases:
  - name: db
    engine: PG
    production: true
    cluster_name: my-cluster
    db_name: {app_name}db
    db_user: {app_name}user

services:
  - name: api
    envs:
      # Use pool instead of direct connection
      - key: DATABASE_URL
        value: ${db.{app_name}_pool.DATABASE_URL}
```

**Pool modes explained**:
| Mode | Use Case | Behavior |
|------|----------|----------|
| `transaction` | **Default, most apps** | Connection returned after each transaction |
| `session` | Long-running connections | Connection held for entire session |
| `statement` | Simple queries only | Connection returned after each statement |

**Generate SQL for connection tuning**:
```sql
-- ============================================
-- Connection Tuning for Pooled Connections
-- ============================================

-- Set statement timeout (prevent long-running queries)
ALTER USER {app_name}user SET statement_timeout = '30s';

-- Set idle transaction timeout (release hung connections)
ALTER USER {app_name}_user SET idle_in_transaction_session_timeout = '60s';

-- Limit connections per user (optional)
ALTER USER {app_name}_user CONNECTION LIMIT 50;
```

---

## Password Generation

**Never use weak passwords.** Generate cryptographically secure passwords:

```bash
# Recommended: 32-character base64 (strong, URL-safe with encoding)
openssl rand -base64 32

# Alternative: 32-character alphanumeric
openssl rand -hex 16

# Alternative: Using Python
python3 -c "import secrets; print(secrets.token_urlsafe(32))"

# Alternative: Using Node.js
node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"
```

**Password requirements for DO Managed Postgres**:
- Minimum 8 characters (recommend 32+)
- Mix of letters, numbers, symbols allowed
- Avoid special characters that need URL encoding: `@`, `:`, `/`, `?`, `#`

---

## ORM Configuration Templates

### Prisma (Node.js/TypeScript)

**`prisma/schema.prisma`**:
```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["{app_name}"]
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  name  String?

  @@schema("{app_name}")
}
```

**`.env`**:
```bash
DATABASE_URL="postgresql://{app_name}_user:PASSWORD@HOST:25060/defaultdb?sslmode=require&schema={app_name}"
```

**Initialize Prisma with schema**:
```bash
# Using nvm (assumed available)
nvm use 20
npx prisma generate
npx prisma db push  # or npx prisma migrate dev
```

---

### SQLAlchemy (Python)

**`database.py`**:
```python
from sqlalchemy import create_engine, MetaData
from sqlalchemy.orm import declarative_base, sessionmaker
import os

DATABASE_URL = os.environ["DATABASE_URL"]
SCHEMA = "{app_name}"

# Create engine with schema
engine = create_engine(
    DATABASE_URL,
    connect_args={"options": f"-csearch_path={SCHEMA}"},
    pool_size=5,
    max_overflow=10,
    pool_pre_ping=True,  # Verify connections before use
)

# Bind metadata to schema
metadata = MetaData(schema=SCHEMA)
Base = declarative_base(metadata=metadata)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

**`models.py`**:
```python
from sqlalchemy import Column, Integer, String
from database import Base

class User(Base):
    __tablename__ = "users"
    # __table_args__ = {"schema": "{app_name}"}  # Already set via metadata
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    name = Column(String)
```

**Install with uv** (assumed available):
```bash
uv pip install sqlalchemy psycopg2-binary
```

---

### Drizzle (Node.js/TypeScript)

**`drizzle.config.ts`**:
```typescript
import type { Config } from "drizzle-kit";

export default {
  schema: "./src/db/schema.ts",
  out: "./drizzle",
  driver: "pg",
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
  },
  schemaFilter: ["{app_name}"],
} satisfies Config;
```

**`src/db/schema.ts`**:
```typescript
import { pgTable, pgSchema, serial, text, varchar } from "drizzle-orm/pg-core";

export const appSchema = pgSchema("{app_name}");

export const users = appSchema.table("users", {
  id: serial("id").primaryKey(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  name: text("name"),
});
```

**`src/db/index.ts`**:
```typescript
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import * as schema from "./schema";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
});

export const db = drizzle(pool, { schema });
```

---

### TypeORM (Node.js/TypeScript)

**`data-source.ts`**:
```typescript
import { DataSource } from "typeorm";

export const AppDataSource = new DataSource({
  type: "postgres",
  url: process.env.DATABASE_URL,
  schema: "{app_name}",
  ssl: { rejectUnauthorized: false },
  entities: ["src/entities/*.ts"],
  migrations: ["src/migrations/*.ts"],
  synchronize: false, // Use migrations in production
});
```

**`src/entities/User.ts`**:
```typescript
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity({ schema: "{app_name}" })
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  email: string;

  @Column({ nullable: true })
  name: string;
}
```

---

## Database Migrations

### Alembic (Python/SQLAlchemy)

**Setup**:
```bash
uv pip install alembic
alembic init alembic
```

**`alembic/env.py`** (key modifications):
```python
from sqlalchemy import engine_from_config, pool
from alembic import context
import os

# Import your models
from app.database import Base, SCHEMA
from app.models import *  # noqa

config = context.config

# Set database URL from environment
config.set_main_option("sqlalchemy.url", os.environ["DATABASE_URL"])

target_metadata = Base.metadata


def run_migrations_online():
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
        connect_args={"options": f"-csearch_path={SCHEMA}"},
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            version_table_schema=SCHEMA,  # Store alembic version in app schema
            include_schemas=True,
        )

        with context.begin_transaction():
            context.run_migrations()
```

**Create and run migrations**:
```bash
# Create migration
alembic revision --autogenerate -m "create users table"

# Run migrations
alembic upgrade head

# Check current version
alembic current
```

---

### Prisma Migrate (Node.js)

**Setup** (assumes Prisma schema already configured):
```bash
# Development: Create and apply migration
npx prisma migrate dev --name init

# Production: Apply pending migrations
npx prisma migrate deploy

# Reset database (WARNING: destroys data)
npx prisma migrate reset
```

**Migration files location**: `prisma/migrations/`

---

### Drizzle Migrate (Node.js)

**Generate migrations**:
```bash
npx drizzle-kit generate:pg
```

**Apply migrations**:
```typescript
// src/db/migrate.ts
import { drizzle } from "drizzle-orm/node-postgres";
import { migrate } from "drizzle-orm/node-postgres/migrator";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
});

const db = drizzle(pool);

async function main() {
  await migrate(db, { migrationsFolder: "./drizzle" });
  await pool.end();
}

main();
```

```bash
npx tsx src/db/migrate.ts
```

---

### Raw SQL Migrations (Framework-agnostic)

For apps not using ORMs, use numbered SQL files:

```
migrations/
├── 001_create_users.sql
├── 002_add_user_email_index.sql
└── 003_create_posts.sql
```

**`migrations/001_create_users.sql`**:
```sql
-- Migration: 001_create_users
-- Created: {timestamp}

BEGIN;

CREATE TABLE IF NOT EXISTS {app_name}.users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_users_email ON {app_name}.users(email);

-- Record migration
CREATE TABLE IF NOT EXISTS {app_name}._migrations (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    applied_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

INSERT INTO {app_name}._migrations (name) VALUES ('001_create_users');

COMMIT;
```

**Apply manually**:
```bash
psql "$DATABASE_URL" -f migrations/001_create_users.sql
```

---

## Execution Guide Template

Generate `DB-SETUP.md` with every database setup:

```markdown
# Database Setup Guide

## Prerequisites

- [ ] Access to DigitalOcean Managed Postgres cluster
- [ ] `psql` client installed (or pgAdmin/DBeaver)
- [ ] Admin connection string from DO Console

## Get Admin Connection String

### Option 1: DigitalOcean Console
1. Go to: Databases → Your Cluster → Connection Details
2. Copy the connection string

### Option 2: doctl CLI
```bash
doctl databases connection <cluster-id>
```

Find cluster ID with: `doctl databases list`

## Execution Steps

### Step 1: Generate Secure Passwords

```bash
# Generate passwords for each user
openssl rand -base64 32  # For {app_name}_user
```

Save these securely - you'll need them for app configuration.

### Step 2: Edit SQL Files

Replace all `CHANGE_ME_*` placeholders in:
- `db-users.sql` — Set actual passwords

### Step 3: Run Scripts in Order

```bash
# Connect as admin
ADMIN_URL="postgresql://doadmin:PASSWORD@host:25060/defaultdb?sslmode=require"

# 1. Create schemas
psql "$ADMIN_URL" -f db-setup.sql

# 2. Create users
psql "$ADMIN_URL" -f db-users.sql

# 3. Grant permissions
psql "$ADMIN_URL" -f db-permissions.sql
```

### Step 4: Verify Setup

```bash
# Test connection with new user
APP_URL="postgresql://{app_name}_user:PASSWORD@host:25060/defaultdb?sslmode=require"
psql "$APP_URL" -c "SELECT current_schema();"
# Should return: {app_name}
```

### Step 5: Save Credentials

**For App Platform deployment** (→ see deployment skill):

1. Go to: GitHub Repository → Settings → Secrets → Actions
2. Add secret: `DATABASE_URL`
3. Value: `postgresql://{app_name}_user:YOUR_PASSWORD@host:25060/defaultdb?sslmode=require`

**For local development** (→ see dev-containers skill):

Add to `.env.local` (git-ignored):
```bash
DATABASE_URL=postgresql://{app_name}_user:PASSWORD@host:25060/defaultdb?sslmode=require
```

## Verification Queries

```sql
-- Check schema exists
SELECT schema_name FROM information_schema.schemata WHERE schema_name = '{app_name}';

-- Check user permissions
SELECT grantee, privilege_type 
FROM information_schema.role_table_grants 
WHERE grantee = '{app_name}_user';

-- Verify isolation (should NOT see other schemas)
SET ROLE {app_name}_user;
SELECT schema_name FROM information_schema.schemata;
RESET ROLE;
```

## Troubleshooting

See the troubleshooting section in the postgres skill or use the **troubleshooting skill** for runtime issues.
```

---


## Bundled Scripts

### Script: `secure_setup.sh` / `secure_setup.py` (Recommended for Path B)

**Hands-free secure setup** — creates user and stores credentials directly in GitHub Secrets.
Password is NEVER displayed.

```bash
# Bash version
./scripts/secure_setup.sh \
  --admin-url "$ADMIN_URL" \
  --app-name myapp \
  --schema myapp \
  --repo owner/repo \
  --env production

# Python version (cross-platform)
python scripts/secure_setup.py \
  --admin-url "$ADMIN_URL" \
  --app-name myapp \
  --repo owner/repo \
  --env production
```

**What it does**:
1. Generates secure password (never printed)
2. Creates schema and user in database
3. Grants full permissions with isolation
4. Stores `DATABASE_URL` directly in GitHub Secrets
5. Clears password from memory

**Prerequisites**:
```bash
# Required tools
psql --version          # PostgreSQL client
gh auth status          # GitHub CLI (authenticated)

# Test repo access
gh secret list --repo owner/repo
```

**Options**:
| Flag | Description |
|------|-------------|
| `--admin-url` | Admin connection string (required) |
| `--app-name` | Application name (required) |
| `--repo` | GitHub repository owner/repo (required) |
| `--schema` | Schema name (defaults to app-name) |
| `--env` | GitHub environment (staging, production) |
| `--secret-name` | Secret name (default: DATABASE_URL) |
| `--dry-run` | Show plan without executing |
| `--skip-confirm` | Skip confirmation prompt |

---

### Other Scripts (Development / Manual Use)

> **Note**: For production Path B setups, prefer `secure_setup.sh` above.
> These scripts are useful for development, debugging, and manual workflows.

#### Prerequisites

```bash
# Install psycopg2 with uv
uv pip install psycopg2-binary
```

#### Script: `create_schema_user.py`

Creates a schema with dedicated user. Supports both generate and execute modes.

```bash
# Generate SQL files (for manual review)
python scripts/create_schema_user.py myapp myapp_user "password" \
  --generate --output-dir ./sql

# Execute directly (dev/test only)
python scripts/create_schema_user.py myapp myapp_user "password" \
  --execute --connection-string "$ADMIN_URL"
```

#### Script: `list_schemas_users.py`

Audit existing schemas and their permissions.

```bash
python scripts/list_schemas_users.py "$ADMIN_URL"
```

**Output**: Table of schemas, owners, users, and table counts.

#### Script: `generate_connection_string.py`

Generate formatted connection strings for application users.

```bash
python scripts/generate_connection_string.py "$ADMIN_URL" myapp_user "password"
```

**Output**: Connection string in multiple formats (URI, components, env vars).

#### Script: `add_client.py`

Batch operation: Add new client/tenant to multi-tenant setup.

```bash
python scripts/add_client.py \
  <cluster-id> \
  "$ADMIN_URL" \
  new_client \
  --create-pool
```

#### Script: `cleanup_client.py`

Remove a client/tenant (with confirmation).

```bash
python scripts/cleanup_client.py "$ADMIN_URL" old_client --confirm
```

#### Script: `get_admin_conn.sh`

Helper to fetch admin connection string via doctl.

```bash
./scripts/get_admin_conn.sh <cluster-id>
```

---

## doctl Reference

### Cluster Management

```bash
# List clusters
doctl databases list

# Get cluster details
doctl databases get <cluster-id>

# Get admin connection string
doctl databases connection <cluster-id>

# Create new cluster
doctl databases create my-cluster \
  --engine pg \
  --version 16 \
  --region nyc3 \
  --size db-s-1vcpu-2gb \
  --num-nodes 1
```

### Connection Pools

```bash
# Create pool
doctl databases pool create <cluster-id> myapp_pool \
  --db defaultdb \
  --mode transaction \
  --size 25 \
  --user myapp_user

# List pools
doctl databases pool list <cluster-id>

# Get pool connection string
doctl databases pool get <cluster-id> myapp_pool
```

### Firewall Rules

```bash
# Add IP whitelist
doctl databases firewalls append <cluster-id> --rule ip_addr:203.0.113.0

# Add App Platform apps
doctl databases firewalls append <cluster-id> --rule app:<app-id>

# List rules
doctl databases firewalls list <cluster-id>
```

### Replicas

```bash
# Create read replica
doctl databases replica create <cluster-id> my-replica \
  --region nyc3 \
  --size db-s-1vcpu-2gb

# List replicas
doctl databases replica list <cluster-id>
```

---

## Troubleshooting

### "permission denied for schema"

**Cause**: User lacks USAGE permission on schema.

**Fix**:
```sql
GRANT USAGE ON SCHEMA {schema_name} TO {username};
```

### "relation does not exist"

**Cause**: Wrong `search_path` or schema not specified.

**Fix**:
```sql
-- Check current search_path
SHOW search_path;

-- Option 1: Use schema-qualified name
SELECT * FROM myapp.users;

-- Option 2: Set search_path
SET search_path TO myapp;
```

### "too many connections"

**Cause**: Connection pool exhausted or too many direct connections.

**Diagnosis**:
```sql
SELECT count(*) FROM pg_stat_activity;
SHOW max_connections;
```

**Fixes**:
1. Use connection pooling (see Workflow 4)
2. Set per-user limits: `ALTER USER myapp_user CONNECTION LIMIT 20;`
3. Tune application pool size
4. Upgrade cluster size

### "User can access wrong schema"

**Cause**: Public schema access not revoked.

**Fix**:
```sql
-- Verify current permissions
SELECT nspname, has_schema_privilege('{username}', nspname, 'USAGE')
FROM pg_namespace;

-- Revoke public access
REVOKE ALL ON SCHEMA public FROM {username};
```

### "SSL connection required"

**Cause**: Missing `sslmode=require` in connection string.

**Fix**: Ensure connection string includes:
```
?sslmode=require
```

### "Connection refused" from App Platform

**Cause**: Firewall rules not allowing App Platform.

**Fix**:
```bash
# Get your app ID
doctl apps list

# Add firewall rule
doctl databases firewalls append <cluster-id> --rule app:<app-id>
```

→ For runtime debugging, use the **troubleshooting skill**.

---

## Integration with Other Skills

### → designer skill

The designer skill handles database attachment in app spec. **Use Path A** for most cases:

```yaml
# Generated by designer skill (Path A - bindable variables)
databases:
  - name: db
    engine: PG
    production: true              # REQUIRED for bindable variables
    cluster_name: my-cluster      # Must exist (created via doctl)
    db_name: myappdb              # Must exist (created via doctl)
    db_user: myappuser            # Must exist (created via doctl)

services:
  - name: api
    envs:
      - key: DATABASE_URL
        value: ${db.DATABASE_URL}   # Auto-populated by App Platform!
```

The postgres skill provides:
1. doctl commands to create the database and user
2. SQL scripts to grant permissions (still required!)

### → deployment skill

**Path A**: No GitHub Secrets needed for database credentials!
App Platform populates `${db.DATABASE_URL}` automatically.

**Path B** (schema isolation): Store credentials in GitHub Secrets:

```yaml
# Generated by deployment skill (.github/workflows/deploy.yml)
env:
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
```

### → dev-containers skill

For local development with production parity:

```yaml
# Generated by dev-containers skill (docker-compose.yml)
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: myappuser
      POSTGRES_PASSWORD: local_dev_password
      POSTGRES_DB: myappdb
    volumes:
      - ./db-permissions.sql:/docker-entrypoint-initdb.d/01-permissions.sql
```

The postgres skill's SQL permission scripts work for local setup too.

### → troubleshooting skill

For runtime database connectivity issues:
- Connection timeouts → Check trusted sources
- Bindable variables not populated → Verify `production: true` and names match exactly
- Permission denied at runtime → Run permission scripts as doadmin
- SSL errors → Ensure `?sslmode=require` in connection string

Use the **troubleshooting skill's Alpine debug pattern** to verify:
```bash
# In running container
echo $DATABASE_URL
# Should show: postgresql://myappuser:AVNS_xxx@host:25060/myappdb?sslmode=require
```

---

## Opinionated Defaults

| Decision | Default | Rationale |
|----------|---------|-----------|
| **Path** | **Path A (bindable vars)** | **Simplest, no credential management** |
| User creation | `doctl databases user create` | DO manages passwords |
| Database creation | `doctl databases db create` | Works with bindable variables |
| Permissions | Still via SQL as doadmin | Required even with Path A |
| SSL Mode | `require` | Security - always encrypted |
| Connection pooling | Transaction mode | Best for most web applications |
| Schema (Path B only) | Named schema, not `public` | Isolation for multi-tenant |
| Public revocation (Path B only) | Always revoke | Prevent cross-tenant access |

---

## File Artifacts Summary

| File | Purpose | Path A | Path B |
|------|---------|--------|--------|
| `db-permissions-path-a.sql` | Grant statements for doctl users | ✅ Required | — |
| `db-setup.sql` | Schema creation | — | ✅ Required |
| `db-users.sql` | User creation with passwords | — | ✅ Required |
| `db-permissions.sql` | Grant statements with isolation | — | ✅ Required |
| `db-connections.env` | Connection string templates | — | ✅ Required |
| `DB-SETUP.md` | Execution guide | Optional | ✅ Recommended |

---

## Documentation Links

- [DO Managed Databases](https://docs.digitalocean.com/products/databases/postgresql/)
- [Database Users & Databases](https://docs.digitalocean.com/products/databases/postgresql/how-to/manage-users-and-databases/)
- [Modify User Privileges](https://docs.digitalocean.com/products/databases/postgresql/how-to/modify-user-privileges/)
- [Connection Pools](https://docs.digitalocean.com/products/databases/postgresql/how-to/manage-connection-pools/)
- [Firewall Rules](https://docs.digitalocean.com/products/databases/postgresql/how-to/secure-database/)
- [doctl databases reference](https://docs.digitalocean.com/reference/doctl/reference/databases/)
